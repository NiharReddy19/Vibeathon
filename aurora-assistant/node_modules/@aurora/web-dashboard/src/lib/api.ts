import { API_ROUTES, Recipe, ActionRequest, ActionResult, RecipeRunResult, APIError } from '@aurora/shared';

const ENGINE_URL = import.meta.env.VITE_ENGINE_URL || 'http://localhost:8080';
const ENGINE_TOKEN = import.meta.env.VITE_ENGINE_TOKEN || '';
const MOCK_MODE = import.meta.env.VITE_MOCK_MODE === 'true';

class APIClient {
  private baseURL: string;
  private token: string;
  private mockMode: boolean;

  constructor(baseURL: string, token: string, mockMode: boolean = false) {
    this.baseURL = baseURL;
    this.token = token;
    this.mockMode = mockMode;
  }

  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    if (this.mockMode) {
      return this.mockRequest<T>(endpoint, options);
    }

    const url = `${this.baseURL}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.token}`,
      ...options.headers,
    };

    try {
      const response = await fetch(url, { ...options, headers });
      
      if (!response.ok) {
        const error: APIError = await response.json();
        throw new Error(error.error || 'Request failed');
      }

      return await response.json();
    } catch (error) {
      console.error('API request failed:', error);
      throw error;
    }
  }

  private async mockRequest<T>(endpoint: string, options: RequestInit): Promise<T> {
    // Mock delay
    await new Promise(resolve => setTimeout(resolve, 300));

    console.log('Mock request:', endpoint, options.method);

    // Treat undefined method as GET (fetch default)
    const method = (options && (options.method as string | undefined)) || 'GET';

    // Mock responses for different endpoints
    if (endpoint.includes('/recipes') && method === 'GET') {
      // list or get-by-id
      return this.getMockRecipes() as T;
    }

    if (endpoint.includes('/recipes') && method === 'POST') {
      const body = JSON.parse(options.body as string);
      return this.createMockRecipe(body) as T;
    }

    if (endpoint.includes('/recipes/') && endpoint.includes('/run') && method === 'POST') {
      return this.mockRecipeRun() as T;
    }

    if (endpoint.includes('/recipes/') && method === 'PUT') {
      const body = JSON.parse(options.body as string);
      // return updated recipe (simple merge)
      const updated = this.createMockRecipe(body);
      return updated as T;
    }

    if (endpoint.includes('/recipes/') && method === 'DELETE') {
      // nothing to return for delete
      return (undefined as unknown) as T;
    }

    if (endpoint.includes('/actions/run') && method === 'POST') {
      const body = JSON.parse(options.body as string);
      return this.mockActionRun(body) as T;
    }

    throw new Error('Mock endpoint not implemented: ' + endpoint + ' ' + method);
  }

  private getMockRecipes(): Recipe[] {
    return [
      {
        id: 'recipe-1',
        name: 'Open Dev Environment',
        description: 'Opens VS Code and starts the terminal',
        actions: [
          {
            action: 'openApp',
            params: { app_name: 'Visual Studio Code' },
            requestId: 'req-1',
            timestamp: Date.now(),
          },
        ],
        createdAt: Date.now() - 86400000,
        updatedAt: Date.now() - 86400000,
      },
      {
        id: 'recipe-2',
        name: 'Daily Standup Prep',
        description: 'Opens relevant apps for standup',
        actions: [
          {
            action: 'openApp',
            params: { app_name: 'Slack' },
            requestId: 'req-2',
            timestamp: Date.now(),
          },
          {
            action: 'openApp',
            params: { app_name: 'Chrome' },
            requestId: 'req-3',
            timestamp: Date.now(),
          },
        ],
        createdAt: Date.now() - 172800000,
        updatedAt: Date.now() - 172800000,
      },
    ];
  }

  private createMockRecipe(data: Partial<Recipe>): Recipe {
    return {
      id: `recipe-${Date.now()}`,
      name: data.name || 'New Recipe',
      description: data.description,
      actions: data.actions || [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
  }

  private mockRecipeRun(): RecipeRunResult {
    return {
      recipeId: 'recipe-1',
      ok: true,
      results: [
        {
          ok: true,
          data: { message: 'App opened successfully' },
          requestId: 'req-1',
          timestamp: Date.now(),
        },
      ],
    };
  }

  private mockActionRun(action: ActionRequest): ActionResult {
    return {
      ok: true,
      data: { message: `Action ${action.action} executed`, params: action.params },
      requestId: action.requestId,
      timestamp: Date.now(),
    };
  }

  // Public API methods
  async listRecipes(): Promise<Recipe[]> {
    return this.request<Recipe[]>(API_ROUTES.RECIPES);
  }

  async getRecipe(id: string): Promise<Recipe> {
    return this.request<Recipe>(API_ROUTES.RECIPE_BY_ID(id));
  }

  async createRecipe(recipe: Omit<Recipe, 'id' | 'createdAt' | 'updatedAt'>): Promise<Recipe> {
    return this.request<Recipe>(API_ROUTES.RECIPES, {
      method: 'POST',
      body: JSON.stringify(recipe),
    });
  }

  async updateRecipe(id: string, recipe: Partial<Recipe>): Promise<Recipe> {
    return this.request<Recipe>(API_ROUTES.RECIPE_BY_ID(id), {
      method: 'PUT',
      body: JSON.stringify(recipe),
    });
  }

  async deleteRecipe(id: string): Promise<void> {
    return this.request<void>(API_ROUTES.RECIPE_BY_ID(id), {
      method: 'DELETE',
    });
  }

  async runRecipe(id: string): Promise<RecipeRunResult> {
    return this.request<RecipeRunResult>(API_ROUTES.RUN_RECIPE(id), {
      method: 'POST',
    });
  }

  async runAction(action: ActionRequest): Promise<ActionResult> {
    return this.request<ActionResult>(API_ROUTES.RUN_ACTION, {
      method: 'POST',
      body: JSON.stringify(action),
    });
  }
}

export const apiClient = new APIClient(ENGINE_URL, ENGINE_TOKEN, MOCK_MODE);
